//*****************************************************************
// File:   gcl.jj
// Author: Procesadores de Lenguajes-University of Zaragoza
// Date:   enero 25
// Coms:   compilar mediante "ant"
//*****************************************************************

///////////////////////////////////////////////////////////////////////////////
// 1. ANALIZADOR LÉXICO
///////////////////////////////////////////////////////////////////////////////

options {
    IGNORE_CASE = true;
    COMMON_TOKEN_ACTION = true;
}

PARSER_BEGIN(gcl)

package traductor;

import lib.symbolTable.*;
import lib.symbolTable.exceptions.*;
import lib.tools.codeGeneration.*;
import lib.tools.codeGeneration.PCodeInstruction.OpCode;

import java.util.*;

public class gcl {
    // tabla de símbolos
    static SymbolTable st;

    // código generado
    static CodeBlock code = new CodeBlock();
    
   public static void main(String[] args) {
	   gcl parser = null;
	   
        for(int i = 0; i < CGUtils.memorySpaces.length; ++i) {
            // El offset de cada nivel empieza en 3, los primeros tres espacios son reservados (Tema 5, lección 10)
            CGUtils.memorySpaces[i] = 3;
        }

	   try {
           st = new SymbolTable();

		   if(args.length == 0) {
			   parser = new gcl(System.in);
		   }
		   else {
			   parser = new gcl(new java.io.FileInputStream(args[0]));
		   }
		   //Programa es el símbolo inicial de la gramática
		   parser.Programa();

		   System.out.println("***** Análisis terminado con éxito *****");

           System.out.println("\n" + code.toString());

           System.out.println("***** P-Code generado *****");
	   }
	   catch (java.io.FileNotFoundException e) {
		   System.out.println ("Fichero " + args[0] + " no encontrado.");
	   }
	   catch (TokenMgrError e) {
		   System.out.println("LEX_ERROR: " + e.getMessage());
	   }
	   catch (Exception e) {
			System.out.println("Ha ocurrido una excepción: " + e.getMessage());
	   }
	}

    // inserta todos los símbolos de "lVars" de tipo "aT" y los marca como ref si "isRef",
    // auxiliar para "parametros_declaraciones" (los parámetros de la declaración de una función/procedimiento)
    private static void insertSymbols(AtribTipo aT, boolean isRef, ArrayList<String> lVars) {
        for (String id : lVars) {
            try {
                Symbol sV = null;
                if (aT.isArray) {
                    sV = new SymbolArray(id, 0, aT.size-1, aT.type);
                } else {
                    switch(aT.type) {
                        case INT:
                            sV = new SymbolInt(id); break;
                        case BOOL:
                            sV = new SymbolBool(id); break;
                        case CHAR:
                            sV = new SymbolChar(id); break;
                        default:
                            System.out.println("Error: tipo no definido para variable \"" + id + "\".");
                    }
                }
                if (sV != null) {
                    sV.parClass = isRef ? Symbol.ParameterClass.REF : Symbol.ParameterClass.VAL;
                    sV.offset = CGUtils.memorySpaces[st.level]++;
                    st.insertSymbol(sV);
                    printMessage("Tabla de símbolos",
                        String.format("\"%s\" %d (offset %d).", sV.name, st.level, sV.offset));
                }
            } catch (AlreadyDefinedSymbolException e) {
                System.out.println("Error: Identificador ya existe: \"" + id + "\"");
            }
        }
    }

    private static boolean typeNotEqual(Symbol.Types esperado, Symbol.Types real, String error) {
        if(esperado == real) {
            if(error != null) printError(error);
            return false;
        }
        return true;
    }

    private static boolean typeEqual(Symbol.Types esperado, Symbol.Types real, String error) {
        if(esperado != real) {
            if(error != null) printError(error);
            return false;
        }
        return true;
    }

    private static boolean typeNotEqual(List<Symbol.Types> esperado, Symbol.Types real, String error) {
        if(!esperado.isEmpty()) {
            for(Symbol.Types t : esperado) {
                if(t == real) {
                    if(error != null) printError(error);
                    return false;
                }
            }
        }
        return true;
    }

    private static boolean typeEqual(Symbol.Types esperado, List<Symbol.Types> real, String error) {
        if(!real.isEmpty()) {
            for(Symbol.Types t : real) {
                if(esperado != t) {
                    if(error != null) printError(error);
                    return false;
                }
            }
        }
        return true;
    }

    private static boolean typeNotEqual(List<Symbol.Types> esperado, ArrayList<String> real) {
        boolean ok = true;
        Symbol s;
        for(String i : real) {
            try {
                s = st.getSymbol(i);
                ok = ok && typeNotEqual(esperado, s.type, String.format("leer_lin o leer incompatible con tipo de dato \"%s\"", s.type));
            } catch(SymbolNotFoundException e) {
                printError(String.format("Variable \"%s\" no encontrada en tabla de símbolos.", i));
            }
        }
        return ok;
    }

    private static CodeBlock insertProcedure(Token identificador, ArrayList<Symbol> parametros, CodeBlock cuerpo) {
        SymbolProcedure sProc = new SymbolProcedure(identificador.image, parametros);
        CodeBlock cb = new CodeBlock();
        
        try {
            st.insertSymbol(sProc);
        } catch(AlreadyDefinedSymbolException e) {
            printError(String.format("Ya definido valor de identificador \"%s\".", identificador.image));
        }

        // Punto de entrada del procedimiento
        cb.addLabel(identificador.image);

        // Crear nuevo bloque de activación
        st.insertBlock();

        // Procesar parámetros
        for (Symbol param : parametros) {
            // Asignar posición en el marco de activación
            param.offset = CGUtils.memorySpaces[st.level]++;
            try {
                st.insertSymbol(param);
            } catch (AlreadyDefinedSymbolException e) {
                printError(String.format("Ya definida variable de identificador \"%s\".", param.name));
            }

            // Generar código según el modo de paso
            if (param.parClass == Symbol.ParameterClass.REF) {
                // Paso por referencia
                cb.addInst(PCodeInstruction.OpCode.ASGI);
            } else {
                if (param.type == Symbol.Types.ARRAY) {
                    // Paso por valor de un arreglo
                    cb.addBlock(generarCopiaArray(param));
                } else {
                    // Paso por valor de un escalar
                    cb.addInst(PCodeInstruction.OpCode.ASG);
                }
            }
        }

        // Añadir cuerpo del procedimiento
        //cb.addBlock(cuerpo);

        // Cierre del marco y retorno
        cb.addInst(PCodeInstruction.OpCode.CSF);

        return cb;
    }

    private static CodeBlock insertFunction(Token identificador, AtribTipo returnType, ArrayList<Symbol> parametros) {
        CodeBlock cb = new CodeBlock();
        if(returnType.type != Symbol.Types.INT && returnType.type != Symbol.Types.BOOL && returnType.type != Symbol.Types.CHAR) {
            printError(String.format("Una función solo puede devolver valores de tipo INT, BOOL o CHAR. Tipo dado: %s.", returnType.type));
        } else {
            SymbolFunction sFunc = new SymbolFunction(identificador.image, parametros, returnType.type);
            try {
                sFunc.offset = CGUtils.memorySpaces[st.level]++;
                st.insertSymbol(sFunc);
                insertParameters(parametros);
                sFunc.tam = CGUtils.memorySpaces[st.level] - 3;
            } catch(AlreadyDefinedSymbolException e) {
                printError(String.format("Ya definido valor de identificador \"%s\".", identificador.image));
            }
        }
        return cb;
    }

    /**
     * Genera el código para copiar un array pasado por valor.
     *
     * @param array Array del que se genera la copia.
     * @return Bloque de código que genera la copia del array.
     */
    private static CodeBlock generarCopiaArray(Symbol array) {
        CodeBlock cb = new CodeBlock();

        String etiqueta_inicio = array.name + "_copia_inicio";
        String etiqueta_final  = array.name + "_copia_final";

        // Longitud del array = maxInd - minInd + 1
        SymbolArray symbol_array = (SymbolArray) array;
        int longitud = symbol_array.maxInd - symbol_array.minInd + 1;

        // Inicializar índice: idx = 0
        cb.addInst(OpCode.STC, 0);

        // Etiqueta de inicio de bucle
        cb.addLabel(etiqueta_inicio);

        // Comparar: idx < longitud, si no se cumple saltar al final
        cb.addInst(OpCode.DUP);                      // duplicar idx (LT lo destruye)
        cb.addInst(OpCode.STC, longitud);            // cargar longitud
        cb.addInst(OpCode.LT);                       // comparar idx < longitud
        cb.addInst(OpCode.JMF, etiqueta_final);      // si no, saltar al final

        // Cargar elemento origen: DRF [base + idx]
        int bloques_diferencia = st.level - array.nivel;
        cb.addInst(OpCode.SRF, bloques_diferencia, array.offset); // dirección base origen
        cb.addInst(OpCode.SWP);                                   // traer idx arriba
        cb.addInst(OpCode.PLUS);                                  // base + idx
        cb.addInst(OpCode.DRF);                                   // cargar valor

        // Guardar en destino: ASG [base + idx] = valor
        cb.addInst(OpCode.SRF, bloques_diferencia, array.offset); // dirección base destino
        cb.addInst(OpCode.SWP);                                   // traer idx arriba
        cb.addInst(OpCode.PLUS);                                  // base + idx
        cb.addInst(OpCode.ASG);                                   // guardar valor

        // Incrementar idx y repetir
        cb.addInst(OpCode.STC, 1);                // cargar 1
        cb.addInst(OpCode.PLUS);                  // idx = idx + 1
        cb.addInst(OpCode.JMP, etiqueta_inicio);  // saltar al inicio del bucle

        // Fin del bucle
        cb.addLabel(etiqueta_final);

        return cb;
    }

    private static void insertParameters(ArrayList<Symbol> parametros) {
        st.insertBlock();
        for(Symbol param : parametros) {
            try {
                param.offset = CGUtils.memorySpaces[st.level]++;
                st.insertSymbol(param);
                printMessage("Tabla de símbolos",
                    String.format("\"%s\" %d (offset %d).", param.name, st.level, param.offset));
            } catch(AlreadyDefinedSymbolException e) {
                printError(String.format("Ya definida variable de identificador \"%s\".", param.name));
            }
        }
    }

    private static void checkParameters(Token identificador, ArrayList<AtribExp> parametros) {
        try {
            Symbol funOproc = st.getSymbol(identificador.image);
            ArrayList<Symbol> params;
            if(funOproc.type == Symbol.Types.FUNCTION || funOproc.type == Symbol.Types.PROCEDURE) {
                if(funOproc.type == Symbol.Types.FUNCTION)
                    params = ((SymbolFunction)funOproc).parList;
                else
                    params = ((SymbolProcedure)funOproc).parList;
            } else {
                printError(String.format("\"%s\" no es una función o procedimiento.", identificador.image));
                return;
            }
            // Comprobar que el número de parámetros es el adecuado
            if(params.size() != parametros.size()) {
                printError(String.format("\"%s\" esperaba %d parámetros. Recibidos %d parámetros.",
                    identificador.image, params.size(), parametros.size()));
                return;
            }
            // Comprobar validez parámetro a parámetro
            for(int i = 0; i < params.size(); ++i) {
                // Comprobar que parámetro pasado es del tipo correcto
                if(params.get(i).type != parametros.get(i).type) {
                    printError(String.format("Parámetro no compatible con valor dado. Tipo esperado: %s. Tipo recibido: %s.",
                        params.get(i).type, parametros.get(i).type));
                }
                // Comprobar que parámetro pasado es una variable si se requiere paso por referencia
                if(params.get(i).parClass == Symbol.ParameterClass.REF && !parametros.get(i).isVar) {
                    printError("Parámetro por referencia. Espera variable, recibido constante.");
                }
            }
        } catch(SymbolNotFoundException e) {
            printError(String.format("\"%s\" no es una función o procedimiento.", identificador.image));
        }
    }

    private static void printError(String error) {
        String crojo = "\u001B[31m";
        String reset = "\u001B[0m";
        System.err.printf("%sError: (%d, %d):%s %s\n", crojo, 
            token.beginLine, token.beginColumn, reset, error);
    }

    private static void printMessage(String label, String message) {
        String verde = "\u001B[32m";
        String reset = "\u001B[0m";
        System.out.printf("%s%s:%s %s\n", verde, label, reset, message);
    }

    /**
     * Declara variables en la tabla de símbolos y asigna espacio en memoria.
     * 
     * @param tipoVar Tipo de las variables a declarar
     * @param ids Lista de identificadores de variables
     * @throws AlreadyDefinedSymbolException Si algún identificador ya existe
     */
    private static void declararVariablesGenerarCodigo(AtribTipo tipoVar, List<String> ids) {
        for (String nombre : ids) {
            try {
                Symbol simbolo = crearSimboloVariable(nombre, tipoVar);
                simbolo.offset = CGUtils.memorySpaces[st.level]++;
                st.insertSymbol(simbolo);
                
                printMessage("Tabla de símbolos", 
                    String.format("\"%s\"  %d (offset %d).", 
                    nombre, st.level, simbolo.offset));
                    
            } catch (AlreadyDefinedSymbolException e) {
                printError(String.format("Ya existe \"%s\".", nombre));
            }
        }
    }

    /**
     * Crea un símbolo de variable según su tipo (entero, booleano, carácter o array).
     * 
     * @param nombre Nombre de la variable
     * @param tipo_variable Tipo y dimensiones de la variable
     * @return Símbolo creado o null si el tipo no es válido o el nombre es null
     */
    private static Symbol crearSimboloVariable(String nombre, AtribTipo tipo_variable) {
        if (nombre == null) {
            return null;
        }
        
        if (tipo_variable.isArray) {
            return new SymbolArray(nombre, 0, tipo_variable.size-1, tipo_variable.type);
        }
        
        switch (tipo_variable.type) {
            case INT:  return new SymbolInt(nombre);
            case BOOL: return new SymbolBool(nombre);
            case CHAR: return new SymbolChar(nombre);
            default:
                printError("Tipo no válido para \"" + nombre + "\"");
                return null;
        }
    }

    /**
     * Genera asignación de variable normal o de un componente de un array en P-Code
     * 
     * @param nombre_variable Nombre de la variable/array a asignar
     * @param expresion_indice Expresión con el índice del componente si es una variable array (null en caso contrario)
     * @param expresion_valor Expresión con el valor a asignar
     * @return el código generado
     */
    private static CodeBlock asignacionVariableGenerarCodigo(
        String nombre_variable, 
        AtribExp expresion_indice, 
        AtribExp expresion_valor
    ) {
        CodeBlock cb = new CodeBlock();
        try {

            // Validación de que la variable tiene asociado un trozo de memoria
            Symbol simbolo_var = st.getSymbol(nombre_variable);
            int offset = simbolo_var.offset;
            if (offset == -1) {
                printError(String.format("Variable \"%s\" no declarada (sin offset).", nombre_variable));
                return cb;
            }
    
            // Calculo de dirección de destino
            int nivel_anidamiento = st.level - simbolo_var.nivel;;
            cb.addComment("assignment " + nombre_variable);
            if (expresion_indice != null) {
                // Caso array: base + índice
                cb.addInst(PCodeInstruction.OpCode.SRF, nivel_anidamiento, offset);
                cb.addBlock(expresion_indice.code);
                cb.addInst(PCodeInstruction.OpCode.PLUS);
                cb.addInst(PCodeInstruction.OpCode.STC, 0);
                cb.addInst(PCodeInstruction.OpCode.SBT);
            } else {
                // Caso variable simple
                cb.addInst(PCodeInstruction.OpCode.SRF, nivel_anidamiento, offset);
            }

            // Generación del valor
            cb.addBlock(expresion_valor.code);

            // Almacenamiento
            cb.addInst(PCodeInstruction.OpCode.ASG);

        } catch (SymbolNotFoundException e) {
            printError(String.format("Variable \"%s\" no encontrada.", nombre_variable));
        }

        return cb;
    }


    /** Genera bucle con inversión en P-Code
     * 
     * @param condicion bloque con el código para evaluar la condición del bucle
     * @param cuerpo bloque con las instrucciones que forman el cuerpo del bucle
     * @return el código generado
     */
    private static CodeBlock bucleGenerarCodigo(AtribExp condicion, CodeBlock cuerpo) {
        CodeBlock cb = new CodeBlock();

        String etiqueta_inicio = CGUtils.newLabel();
        String etiqueta_prueba = CGUtils.newLabel();
        String etiqueta_final  = CGUtils.newLabel();

        // Salto inicial a la prueba invertida
        cb.addInst(OpCode.JMP, etiqueta_prueba);

        // Cuerpo
        cb.addLabel(etiqueta_inicio);
        cb.addBlock(cuerpo);

        // Prueba invertida
        cb.addLabel(etiqueta_prueba);
        cb.addBlock(condicion.code);
        cb.addInst(OpCode.JMF, etiqueta_final);
        cb.addInst(OpCode.JMP, etiqueta_inicio);
        cb.addLabel(etiqueta_final);

        return cb;
    }

    /** Genera bloque switch en P-Code
     * 
     * @param condiciones Lista de expresiones booleanas que determinan cada caso
     * @param cuerpos     Lista de bloques de código a ejecutar para cada caso correspondiente
     * @param otherwise   Bloque de código opcional que se ejecuta cuando ningún caso coincide (puede ser null)
     * @return el código generado
     */
    private static CodeBlock seleccionGenerarCodigo(
        java.util.List<AtribExp> condiciones,
        java.util.List<CodeBlock> cuerpos,
        CodeBlock otherwise
    ) {
        CodeBlock cb = new CodeBlock();

        String etiqueta_final = CGUtils.newLabel();
        java.util.List<String> etiquetas_salto = new java.util.ArrayList<String>();

        // Asociar una etiqueta a cada condición
        for (int i = 0; i < condiciones.size(); i++) {
            etiquetas_salto.add(CGUtils.newLabel());
        }

        // Generar código para cada condición
        for (int i = 0; i < condiciones.size(); i++) {
            // Evaluar la i-ésima condición
            cb.addBlock(condiciones.get(i).code);
            
            // Caso falso: continuar con la siguiente condición
            cb.addInst(OpCode.JMF, etiquetas_salto.get(i));
            
            // Caso verdadero: ejecutar el bloque y saltar al final del switch
            cb.addBlock(cuerpos.get(i));
            cb.addInst(OpCode.JMP, etiqueta_final);

            // Etiqueta para continuar con la siguiente condición si el caso es falso
            cb.addLabel(etiquetas_salto.get(i));
        }

        // Manejar el bloque por defecto (si existe)
        if (otherwise != null) {
            cb.addBlock(otherwise);
        }

        // Etiqueta a la que se salta si alguna condición es verdadera
        cb.addLabel(etiqueta_final);

        return cb;
    }

    public static CodeBlock declaracionProcedimientoGenerarCodigo(
        String nombre,
        ArrayList<Symbol> parametros,
        CodeBlock cuerpo
    ) {
        CodeBlock cb = new CodeBlock();
    
        cb.addLabel(nombre);

        // Asignar parámetros (importante que quien llame haga push en orden)
        for (Symbol param : parametros) {
            cb.addInst(PCodeInstruction.OpCode.SRF, 0, param.offset);
            cb.addInst(PCodeInstruction.OpCode.ASGI);
        }

        cb.addBlock(cuerpo);

        cb.addInst(PCodeInstruction.OpCode.CSF);
        
        return cb;
    }
}

PARSER_END(gcl)

///////////////////////////////////////////////////////////////////////////////
// 2. ANALIZADOR SINTÁCTICO
///////////////////////////////////////////////////////////////////////////////
