CodeBlock escribir_linea() :
{
    ArrayList<AtribExp> args = new ArrayList<AtribExp>();
    CodeBlock c = new CodeBlock();
}
{
    <tESCRIBIR_LIN>
    <tOPENING_PARENTHESIS>
    (args = escribir_params())?
    <tCLOSING_PARENTHESIS>
    {
        for (AtribExp a : args) {
            c.addBlock(a.code);
            int modo = (a.type == Symbol.Types.CHAR) ? 0 : 1;
            c.addInst(OpCode.WRT, modo);
        }
        // Salto de línea
        c.addInst(OpCode.STC, (int)'\n');
        c.addInst(OpCode.WRT, 0);

        return c;
    }
}

CodeBlock escribir() :
{
    ArrayList<AtribExp> args = new ArrayList<AtribExp>();
    CodeBlock c = new CodeBlock();
}
{
    <tESCRIBIR>
    <tOPENING_PARENTHESIS>
    args = escribir_params()
    <tCLOSING_PARENTHESIS>
    {
        for (AtribExp a : args) {
            c.addBlock(a.code);
            int modo = (a.type == Symbol.Types.CHAR) ? 0 : 1;
            c.addInst(OpCode.WRT, modo);
        }
        return c;
    }
}

ArrayList<AtribExp> escribir_params() :
{
    ArrayList<AtribExp> args = new ArrayList<AtribExp>();
    AtribExp a;
}
{
    (a = expresion()
    {
        typeNotEqual(Arrays.asList(Symbol.Types.ARRAY, Symbol.Types.PROCEDURE, Symbol.Types.UNDEFINED),
            a.type, String.format("No se puede escribir tipo de dato \"%s\"", a.type));
        args.add(a);
    }
    (
        <tCOMA> (a = expresion())
        {
            typeNotEqual(Arrays.asList(Symbol.Types.ARRAY, Symbol.Types.PROCEDURE, Symbol.Types.UNDEFINED),
            a.type, String.format("No se puede escribir tipo de dato \"%s\"", a.type));
            args.add(a);
        }
    )*)
    { return args; }
}

CodeBlock leer_linea() :
{
    ArrayList<String> lVars = new ArrayList<String>();
    CodeBlock c = new CodeBlock();
}
{
    <tLEER_LIN>
    <tOPENING_PARENTHESIS>
    (
        (lVars = listaIDs())
        {
            typeNotEqual(Arrays.asList(Symbol.Types.ARRAY, Symbol.Types.PROCEDURE, Symbol.Types.UNDEFINED, Symbol.Types.PROCEDURE), lVars);
            for (String id : lVars) {
                try {
                    Symbol s = st.getSymbol(id);
                    c.addInst(OpCode.SRF, st.level - s.nivel, s.offset);
                    int tipo = (s.type == Symbol.Types.CHAR) ? 0 : 1;
                    c.addInst(OpCode.RD, tipo);
                } catch (SymbolNotFoundException e) {
                    printError("Variable \"" + id + "\" no encontrada.");
                }
            }
        }
    )?
    <tCLOSING_PARENTHESIS>

    { return c; }
}

CodeBlock leer() :
{
    ArrayList<String> lVars = new ArrayList<String>();
    CodeBlock c = new CodeBlock();
}
{
    <tLEER> 
    <tOPENING_PARENTHESIS>
    lVars = listaIDs()
    {
        typeNotEqual(Arrays.asList(Symbol.Types.ARRAY, Symbol.Types.PROCEDURE, Symbol.Types.UNDEFINED, Symbol.Types.PROCEDURE), lVars);
        for(String id : lVars) {
            try {
                Symbol s = st.getSymbol(id);
                c.addInst(OpCode.SRF, st.level - s.nivel, s.offset);
                int tipo = (s.type == Symbol.Types.CHAR) ? 0 : 1;
                c.addInst(OpCode.RD, tipo);
            } catch (SymbolNotFoundException e) {
                printError("Variable \"" + id + "\" no encontrada.");
            }
        }
    }
    <tCLOSING_PARENTHESIS> 
    { return c; }
}

AtribExp entAcar() :
{
    AtribExp i;
}
{
    < tENTACAR >
    <tOPENING_PARENTHESIS>
    i = expresionSimple()
    <tCLOSING_PARENTHESIS>

    {
        if(!typeEqual(Symbol.Types.INT, i.type, String.format("Tipo incorrecto. Se esperaba INT pero se encontró %s.", i.type))) {
            return new AtribExp(Symbol.Types.UNDEFINED, null, false, false); 
        }
        // No hace falta transformarlo porque CHAR e INT son ambos 32 bits en máquina P
        AtribExp resultado = new AtribExp(Symbol.Types.CHAR, null, false, false);
        resultado.code.addBlock(i.code);
        return resultado;
    }
}

AtribExp carAent() :
{
    AtribExp c;
}
{
    < tCARAENT >
    < tOPENING_PARENTHESIS>
    c = primario()
    <tCLOSING_PARENTHESIS>

    {
        if(!typeEqual(Symbol.Types.CHAR, c.type, String.format("Tipo incorrecto. Se esperaba CHAR pero se encontró %s.", c.type))) {
            return new AtribExp(Symbol.Types.UNDEFINED, null, false, false);
        }
        // No hace falta transformarlo porque CHAR e INT son ambos 32 bits en máquina P
        AtribExp resultado = new AtribExp(Symbol.Types.INT, null, false, false);
        resultado.code.addBlock(c.code);
        return resultado;
    }
}
