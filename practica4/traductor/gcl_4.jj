// AUTOGENERADO - NO EDITAR MANUALMENTE
// Este archivo se genera automáticamente por build.sh

// --- INICIO DE main.jj ---
//*****************************************************************
// File:   gcl.jj
// Author: Procesadores de Lenguajes-University of Zaragoza
// Date:   enero 25
// Coms:   compilar mediante "ant"
//*****************************************************************

///////////////////////////////////////////////////////////////////////////////
// 1. ANALIZADOR LÉXICO
///////////////////////////////////////////////////////////////////////////////

options {
    IGNORE_CASE = true;
    COMMON_TOKEN_ACTION = true;
}

PARSER_BEGIN(gcl)

package traductor;

import lib.symbolTable.*;
import lib.symbolTable.exceptions.*;
import lib.tools.codeGeneration.*;
import lib.tools.codeGeneration.PCodeInstruction.OpCode;
import java.io.UnsupportedEncodingException;

import java.util.*;

public class gcl {
    // tabla de símbolos
    static SymbolTable st;

    // código generado
    static CodeBlock code = new CodeBlock();
    
    public static void main(String[] args) {
	   gcl parser = null;
	   
        for(int i = 0; i < CGUtils.memorySpaces.length; ++i) {
            // El offset de cada nivel empieza en 3, los primeros tres espacios son reservados (Tema 5, lección 10)
            CGUtils.memorySpaces[i] = 3;
        }

	   try {
           st = new SymbolTable();

		   if(args.length == 0) {
			   parser = new gcl(System.in);
		   }
		   else {
			   parser = new gcl(new java.io.FileInputStream(args[0]));
		   }
		   //Programa es el símbolo inicial de la gramática
		   parser.Programa();

		   System.out.println("***** Análisis terminado con éxito *****");

           System.out.println("\n" + code.toString());

           System.out.println("***** P-Code generado *****");
	   }
	   catch (java.io.FileNotFoundException e) {
		   System.out.println ("Fichero " + args[0] + " no encontrado.");
	   }
	   catch (TokenMgrError e) {
		   System.out.println("LEX_ERROR: " + e.getMessage());
	   }
	   catch (Exception e) {
			System.out.println("Ha ocurrido una excepción: " + e.getMessage());
	   }
	}

    // inserta todos los símbolos de "lVars" de tipo "aT" y los marca como ref si "isRef",
    // auxiliar para "parametros_declaraciones" (los parámetros de la declaración de una función/procedimiento)
    private static void insertSymbols(AtribTipo aT, boolean isRef, ArrayList<String> lVars) {
        for (String id : lVars) {
            try {
                Symbol sV = null;
                if (aT.isArray) {
                    sV = new SymbolArray(id, 0, aT.size-1, aT.type);
                } else {
                    switch(aT.type) {
                        case INT:
                            sV = new SymbolInt(id); break;
                        case BOOL:
                            sV = new SymbolBool(id); break;
                        case CHAR:
                            sV = new SymbolChar(id); break;
                        default:
                            System.out.println("Error: tipo no definido para variable \"" + id + "\".");
                    }
                }
                if (sV != null) {
                    sV.parClass = isRef ? Symbol.ParameterClass.REF : Symbol.ParameterClass.VAL;
                    sV.offset = CGUtils.memorySpaces[st.level]++;
                    st.insertSymbol(sV);
                    printMessage("Tabla de símbolos",
                        String.format("\"%s\" %d (offset %d).", sV.name, st.level, sV.offset));
                }
            } catch (AlreadyDefinedSymbolException e) {
                System.out.println("Error: Identificador ya existe: \"" + id + "\"");
            }
        }
    }

    private static boolean typeNotEqual(Symbol.Types esperado, Symbol.Types real, String error) {
        if(esperado == real) {
            if(error != null) printError(error);
            return false;
        }
        return true;
    }

    private static boolean typeEqual(Symbol.Types esperado, Symbol.Types real, String error) {
        if(esperado != real) {
            if(error != null) printError(error);
            return false;
        }
        return true;
    }

    private static boolean typeNotEqual(List<Symbol.Types> esperado, Symbol.Types real, String error) {
        if(!esperado.isEmpty()) {
            for(Symbol.Types t : esperado) {
                if(t == real) {
                    if(error != null) printError(error);
                    return false;
                }
            }
        }
        return true;
    }

    private static boolean typeEqual(Symbol.Types esperado, List<Symbol.Types> real, String error) {
        if(!real.isEmpty()) {
            for(Symbol.Types t : real) {
                if(esperado != t) {
                    if(error != null) printError(error);
                    return false;
                }
            }
        }
        return true;
    }

    private static boolean typeNotEqual(List<Symbol.Types> esperado, ArrayList<String> real) {
        boolean ok = true;
        Symbol s;
        for(String i : real) {
            try {
                s = st.getSymbol(i);
                ok = ok && typeNotEqual(esperado, s.type, String.format("leer_lin o leer incompatible con tipo de dato \"%s\"", s.type));
            } catch(SymbolNotFoundException e) {
                printError(String.format("Variable \"%s\" no encontrada en tabla de símbolos.", i));
            }
        }
        return ok;
    }

    private static void insertProcedure(Token identificador, ArrayList<Symbol> parametros) {
        SymbolProcedure sProc = new SymbolProcedure(identificador.image, parametros);
        try {
            // al procedure no hay que darle offset
            st.insertSymbol(sProc);
            insertParameters(parametros);
        } catch(AlreadyDefinedSymbolException e) {
            printError(String.format("Ya definido valor de identificador \"%s\".", identificador.image));
        }
    }

    private static CodeBlock insertFunction(Token identificador, AtribTipo returnType, ArrayList<Symbol> parametros) {
        CodeBlock cb = new CodeBlock();
        if(returnType.type != Symbol.Types.INT && returnType.type != Symbol.Types.BOOL && returnType.type != Symbol.Types.CHAR) {
            printError(String.format("Una función solo puede devolver valores de tipo INT, BOOL o CHAR. Tipo dado: %s.", returnType.type));
        } else {
            SymbolFunction sFunc = new SymbolFunction(identificador.image, parametros, returnType.type);
            try {
                sFunc.offset = CGUtils.memorySpaces[st.level]++;
                st.insertSymbol(sFunc);
                insertParameters(parametros);
            } catch(AlreadyDefinedSymbolException e) {
                printError(String.format("Ya definido valor de identificador \"%s\".", identificador.image));
            }
        }
        return cb;
    }

    /**
     * Genera el código para copiar un array pasado por valor.
     *
     * @param array Array del que se genera la copia.
     * @return Bloque de código que genera la copia del array.
     */
    private static CodeBlock generarCopiaArray(Symbol array) {
        CodeBlock cb = new CodeBlock();

        String etiqueta_inicio = CGUtils.newLabel();//array.name + "_copia_inicio";
        String etiqueta_final  = CGUtils.newLabel();//array.name + "_copia_final";

        SymbolArray symbol_array = (SymbolArray) array;
        int minInd = symbol_array.minInd;
        int maxInd = symbol_array.maxInd;
        int longitud = maxInd - minInd + 1;

        // Let's assume copy will be placed at copyOffset (in current frame)
        int copyOffset = symbol_array.offset;

        // idx = minInd
        cb.addInst(OpCode.STC, minInd);

        cb.addLabel(etiqueta_inicio);

        // if idx >= maxInd + 1 jump to end
        cb.addInst(OpCode.DUP);
        cb.addInst(OpCode.STC, maxInd + 1);
        cb.addInst(OpCode.LT);
        cb.addInst(OpCode.JMF, etiqueta_final);

        // --- Load from original array
        cb.addInst(OpCode.SRF, st.level - array.nivel, array.offset);  // base of original
        cb.addInst(OpCode.DUP);        // duplicate idx
        cb.addInst(OpCode.SWP);        // idx on top
        cb.addInst(OpCode.PLUS);       // address = base + idx
        cb.addInst(OpCode.DRF);        // load value

        // --- Store in local copy
        cb.addInst(OpCode.SRF, 0, copyOffset);  // base of local copy (current frame)
        cb.addInst(OpCode.SWP);        // bring idx up
        cb.addInst(OpCode.PLUS);       // compute address
        cb.addInst(OpCode.ASG);        // store value

        // idx = idx + 1
        cb.addInst(OpCode.STC, 1);
        cb.addInst(OpCode.PLUS);
        cb.addInst(OpCode.JMP, etiqueta_inicio);

        cb.addLabel(etiqueta_final);

        return cb;
    }

    private static void insertParameters(ArrayList<Symbol> parametros) {
        st.insertBlock();
        for(Symbol param : parametros) {
            try {
                param.offset = CGUtils.memorySpaces[st.level];
                if(param instanceof SymbolArray && param.parClass != Symbol.ParameterClass.REF)
                    CGUtils.memorySpaces[st.level] += ((SymbolArray)param).maxInd - ((SymbolArray)param).minInd + 1; 
                else CGUtils.memorySpaces[st.level]++;
                st.insertSymbol(param);
                printMessage("Tabla de símbolos",
                    String.format("\"%s\" %d (offset %d).", param.name, st.level, param.offset));
            } catch(AlreadyDefinedSymbolException e) {
                printError(String.format("Ya definida variable de identificador \"%s\".", param.name));
            }
        }
    }

    private static void checkParameters(Token identificador, ArrayList<AtribExp> parametros) {
        try {
            Symbol funOproc = st.getSymbol(identificador.image);
            ArrayList<Symbol> params;
            if(funOproc.type == Symbol.Types.FUNCTION || funOproc.type == Symbol.Types.PROCEDURE) {
                if(funOproc.type == Symbol.Types.FUNCTION)
                    params = ((SymbolFunction)funOproc).parList;
                else
                    params = ((SymbolProcedure)funOproc).parList;
            } else {
                printError(String.format("\"%s\" no es una función o procedimiento.", identificador.image));
                return;
            }
            // Comprobar que el número de parámetros es el adecuado
            if(params.size() != parametros.size()) {
                printError(String.format("\"%s\" esperaba %d parámetros. Recibidos %d parámetros.",
                    identificador.image, params.size(), parametros.size()));
                return;
            }
            // Comprobar validez parámetro a parámetro
            for(int i = 0; i < params.size(); ++i) {
                // Comprobar que parámetro pasado es del tipo correcto
                if(params.get(i).type != parametros.get(i).type) {
                    printError(String.format("Parámetro no compatible con valor dado. Tipo esperado: %s. Tipo recibido: %s.",
                        params.get(i).type, parametros.get(i).type));
                }
                // Comprobar que parámetro pasado es una variable si se requiere paso por referencia
                if(params.get(i).parClass == Symbol.ParameterClass.REF && parametros.get(i).isConst) {
                    printError("Parámetro por referencia. Espera variable, recibido constante.");
                }
            }
        } catch(SymbolNotFoundException e) {
            printError(String.format("\"%s\" no es una función o procedimiento.", identificador.image));
        }
    }

    private static void printError(String error) {
        String crojo = "\u001B[31m";
        String reset = "\u001B[0m";
        System.err.printf("%sError: (%d, %d):%s %s\n", crojo, 
            token.beginLine, token.beginColumn, reset, error);
    }

    private static void printMessage(String label, String message) {
        String verde = "\u001B[32m";
        String reset = "\u001B[0m";
        System.out.printf("%s%s:%s %s\n", verde, label, reset, message);
    }

    /**
     * Declara variables en la tabla de símbolos y asigna espacio en memoria.
     * 
     * @param tipoVar Tipo de las variables a declarar
     * @param ids Lista de identificadores de variables
     * @throws AlreadyDefinedSymbolException Si algún identificador ya existe
     */
    private static void declararVariablesGenerarCodigo(AtribTipo tipoVar, List<String> ids) {
        for (String nombre : ids) {
            try {
                Symbol var = crearSimboloVariable(nombre, tipoVar);
                var.offset = CGUtils.memorySpaces[st.level];
                if(var instanceof SymbolArray)
                    CGUtils.memorySpaces[st.level] += ((SymbolArray)var).maxInd - ((SymbolArray)var).minInd + 1; 
                else CGUtils.memorySpaces[st.level]++;
                st.insertSymbol(var);
                
                printMessage("Tabla de símbolos", 
                    String.format("\"%s\"  %d (offset %d).", 
                    nombre, st.level, var.offset));
                    
            } catch (AlreadyDefinedSymbolException e) {
                printError(String.format("Ya existe \"%s\".", nombre));
            }
        }
    }

    /**
     * Crea un símbolo de variable según su tipo (entero, booleano, carácter o array).
     * 
     * @param nombre Nombre de la variable
     * @param tipo_variable Tipo y dimensiones de la variable
     * @return Símbolo creado o null si el tipo no es válido o el nombre es null
     */
    private static Symbol crearSimboloVariable(String nombre, AtribTipo tipo_variable) {
        if (nombre == null) {
            return null;
        }
        
        if (tipo_variable.isArray) {
            return new SymbolArray(nombre, 0, tipo_variable.size-1, tipo_variable.type);
        }
        
        switch (tipo_variable.type) {
            case INT:  return new SymbolInt(nombre);
            case BOOL: return new SymbolBool(nombre);
            case CHAR: return new SymbolChar(nombre);
            default:
                printError("Tipo no válido para \"" + nombre + "\"");
                return null;
        }
    }

    /**
     * Genera asignación de variable normal o de un componente de un array en P-Code
     * 
     * @param nombre_variable Nombre de la variable/array a asignar
     * @param expresion_indice Expresión con el índice del componente si es una variable array (null en caso contrario)
     * @param expresion_valor Expresión con el valor a asignar
     * @return el código generado
     */
    private static CodeBlock asignacionVariableGenerarCodigo(
        String nombre_variable, 
        AtribExp expresion_indice, 
        AtribExp expresion_valor
    ) {
        CodeBlock cb = new CodeBlock();
        try {

            // Validación de que la variable tiene asociado un trozo de memoria
            Symbol simbolo_var = st.getSymbol(nombre_variable);
            int offset = simbolo_var.offset;
            if (offset == -1) {
                printError(String.format("Variable \"%s\" no declarada (sin offset).", nombre_variable));
                return cb;
            }
    
            // Calculo de dirección de destino
            int nivel_anidamiento = st.level - simbolo_var.nivel;
            cb.addComment("assignment " + nombre_variable);
            if (expresion_indice != null) {
                // Caso array: base + índice
                cb.addInst(PCodeInstruction.OpCode.SRF, nivel_anidamiento, offset);
                if(simbolo_var.parClass == Symbol.ParameterClass.REF) cb.addInst(PCodeInstruction.OpCode.DRF);
                cb.addBlock(expresion_indice.code);
                cb.addInst(PCodeInstruction.OpCode.PLUS);
                cb.addInst(PCodeInstruction.OpCode.STC, 0);
                cb.addInst(PCodeInstruction.OpCode.SBT);
            } else {
                // Caso variable simple
                cb.addInst(PCodeInstruction.OpCode.SRF, nivel_anidamiento, offset);
                if(st.level <= 0)
                    cb.addInst(PCodeInstruction.OpCode.DRF);
            }

            // Generación del valor
            cb.addBlock(expresion_valor.code);

            // Almacenamiento
            cb.addInst(PCodeInstruction.OpCode.ASG);

        } catch (SymbolNotFoundException e) {
            printError(String.format("Variable \"%s\" no encontrada.", nombre_variable));
        }

        return cb;
    }


    /** Genera bucle con inversión en P-Code
     * 
     * @param condicion bloque con el código para evaluar la condición del bucle
     * @param cuerpo bloque con las instrucciones que forman el cuerpo del bucle
     * @return el código generado
     */
    private static CodeBlock bucleGenerarCodigo(AtribExp condicion, CodeBlock cuerpo) {
        CodeBlock cb = new CodeBlock();

        String etiqueta_inicio = CGUtils.newLabel();
        String etiqueta_prueba = CGUtils.newLabel();
        String etiqueta_final  = CGUtils.newLabel();

        // Salto inicial a la prueba invertida
        cb.addInst(OpCode.JMP, etiqueta_prueba);

        // Cuerpo
        cb.addLabel(etiqueta_inicio);
        cb.addBlock(cuerpo);

        // Prueba invertida
        cb.addLabel(etiqueta_prueba);
        cb.addBlock(condicion.code);
        cb.addInst(OpCode.JMF, etiqueta_final);
        cb.addInst(OpCode.JMP, etiqueta_inicio);
        cb.addLabel(etiqueta_final);

        return cb;
    }

    /** Genera bloque switch en P-Code
     * 
     * @param condiciones Lista de expresiones booleanas que determinan cada caso
     * @param cuerpos     Lista de bloques de código a ejecutar para cada caso correspondiente
     * @param otherwise   Bloque de código opcional que se ejecuta cuando ningún caso coincide (puede ser null)
     * @return el código generado
     */
    private static CodeBlock seleccionGenerarCodigo(
        java.util.List<AtribExp> condiciones,
        java.util.List<CodeBlock> cuerpos,
        CodeBlock otherwise
    ) {
        CodeBlock cb = new CodeBlock();

        String etiqueta_final = CGUtils.newLabel();
        java.util.List<String> etiquetas_salto = new java.util.ArrayList<String>();

        // Asociar una etiqueta a cada condición
        for (int i = 0; i < condiciones.size(); i++) {
            etiquetas_salto.add(CGUtils.newLabel());
        }

        // Generar código para cada condición
        for (int i = 0; i < condiciones.size(); i++) {
            // Evaluar la i-ésima condición
            cb.addBlock(condiciones.get(i).code);
            
            // Caso falso: continuar con la siguiente condición
            cb.addInst(OpCode.JMF, etiquetas_salto.get(i));
            
            // Caso verdadero: ejecutar el bloque y saltar al final del switch
            cb.addBlock(cuerpos.get(i));
            cb.addInst(OpCode.JMP, etiqueta_final);

            // Etiqueta para continuar con la siguiente condición si el caso es falso
            cb.addLabel(etiquetas_salto.get(i));
        }

        // Manejar el bloque por defecto (si existe)
        if (otherwise != null) {
            cb.addBlock(otherwise);
        }

        // Etiqueta a la que se salta si alguna condición es verdadera
        cb.addLabel(etiqueta_final);

        return cb;
    }
}

PARSER_END(gcl)

///////////////////////////////////////////////////////////////////////////////
// 2. ANALIZADOR SINTÁCTICO
///////////////////////////////////////////////////////////////////////////////

// --- INICIO DE tokens.jj ---
// sacado de https://cs.lmu.edu/~ray/notes/javacc/
// "preprocesado"
SKIP: {
  " "
| "\t"
| "\n"
| "\r"
| <"--" (~["\n","\r"])* ("\n"|"\r")> // comentarios monolínea
}

// auxiliares
TOKEN : {
	< #LETTER: (["a"-"z","A"-"Z"]) >
|	< #DIGIT: ["0"-"9"] >
}

// todos los tokens de gcl
// tOTHER no es léxicamente válido, el resto de tokens si
TOKEN : {
     // palabras reservadas
     < tPROGRAMA: "Programa" >
|    < tESCRIBIR_LIN: "escribir_lin" >
|    < tESCRIBIR: "escribir" >
|    < tLEER_LIN: "leer_lin" >
|    < tLEER: "leer" >
|    < tENTACAR: "entAcar" >
|    < tCARAENT: "carAent" >
|    < tREF: "ref" > 
|    < tINTEGER: "entero" >
|    < tCHARACTER: "caracter" >
|    < tBOOLEAN: "booleano" >
|    < tSELECTION: "Sel" >
|    < tEND_SELECTION: "Fsel" >
|    < tCASE: "caso" >
|    < tITERATION: "Mq" >
|    < tEND_ITERATION: "FMq" >
|    < tBEGGINING: "Principio" >
|    < tEND: "Fin" >
|    < tTRUE: "verdadero" >
|    < tFALSE: "falso" >
|    < tOTHERWISE: "dlc" >
|    < tABANDONAR: "abandonar" > 
|    < tNADA: "nada" >
    
     // literales
|    < tSTRING: "\"" ( ("\"\"") | ~["\""] )* "\"" >
|    < tCHAR: "'''" | "'" ~[] "'" > 
|    < tCONSTANT: ( <DIGIT> )+ >
    
     // operadores y símbolos
|    < tCOMA: "," >
|    < tSEMICOLON: ";" >
|    < tUNDERSCORE: "_" >
|    < tASSIGN: ":=" >
|    < tOPENING_SQUARE_BRACKET: "[" >
|    < tCLOSING_SQUARE_BRACKET: "]" >
|    < tCOLON: ":" >
|    < tOPENING_PARENTHESIS: "(" >
|    < tCLOSING_PARENTHESIS: ")" >
|    < tPLUS: "+" >
|    < tMINUS: "-" >
|    < tTIMES: "*" >
|    < tDIVIDE: "/" >
|    < tMOD: "mod" >
|    < tAND: "&" >
|    < tOR: "|" >
|    < tNOT: "!" >
|    < tGT: ">" >
|    < tGE: ">=" >
|    < tLT: "<" >
|    < tLE: "<=" >
|    < tEQUAL: "=" >
|    < tNOTEQUAL: "<>" >
|    < tDOT: "." >

|    < tIDENTIFICADOR: ( <LETTER> | "_" ) ( <LETTER> | <DIGIT> | "_" )* >

|    < tOTHER: ~[] >  // tOTHER no es léxicamente válido, el resto de tokens si
}

// deprecado al parecer, https://parsers.org/javacc21/token-hooks-revisited/
TOKEN_MGR_DECLS : {
    public static void CommonTokenAction(Token t) {
        if(false)
            System.out.printf("(%d,%d): %s \"%s\"%n", 
                t.beginLine, t.beginColumn, getTokenName(t.kind), t.image);
    }

    // función épica que devuelve el token (no su lexema)
    private static String getTokenName(int kind) {
        try {
            java.lang.reflect.Field[] fields = gclConstants.class.getDeclaredFields();
            for (java.lang.reflect.Field field : fields) {
                if (field.getType() == int.class 
                        && field.getInt(null) == kind 
                        && field.getName().startsWith("t")) {
                    return field.getName();
                }
            }
            return "UNKNOWN_TOKEN";
        } catch (IllegalAccessException e) {
            return "ERROR: " + e.getMessage();
        }
    }
}

// --- INICIO DE programa.jj ---
void Programa() :
{
    Token identificadorPrograma;
    CodeBlock cprog, cbloque, cprocfun = new CodeBlock();
}
{
    < tPROGRAMA >
    identificadorPrograma = < tIDENTIFICADOR >

    {
        // Basado en diapositiva 16, Tema 6, Lección 11
        cprog = new CodeBlock();
    }

    ( LOOKAHEAD(3) declaracionVariables() )*
    ( cprocfun = declaracion_proc_func() )?
    < tBEGGINING >
    cbloque = BloqueSentencias()

    {
        // Basado en diapositiva 16, Tema 6, Lección 11
        String etiqEnterProgram = CGUtils.newLabel();
        cprog.addInst(OpCode.ENP, etiqEnterProgram); // Instrucción para saltar al programa ~enter program~
        cprog.addBlock(cprocfun);
        cprog.addComment("Comienzo del programa " + identificadorPrograma.image);
        cprog.addLabel(etiqEnterProgram);
        cprog.addBlock(cbloque);
        cprog.addComment("Fin del programa " + identificadorPrograma.image);
        cprog.addInst(OpCode.LVP); // Instrucción para salir del programa ~leave program~
        code.addBlock(cprog);
    }

    < tEND >
}

CodeBlock BloqueSentencias() :
{
    CodeBlock cprocfun = new CodeBlock(), aux;
}
{
    (
        aux = instruccion()   { cprocfun.addBlock(aux); }
    )*
    { return cprocfun; }
}

// --- INICIO DE tipos.jj ---
AtribTipo tipo() :
{
    AtribTipo aT;
}
{
    (
        LOOKAHEAD(2) 
        aT = tipoArray() 
        | aT = tipoEscalar()
    )
    { return aT; }
}

AtribTipo tipoEscalar() :
{}
{
    <tINTEGER>      { return new AtribTipo(Symbol.Types.INT ); }
    | <tCHARACTER>  { return new AtribTipo(Symbol.Types.CHAR); }
    | <tBOOLEAN>    { return new AtribTipo(Symbol.Types.BOOL); }
}

AtribTipo tipoArray() :
{
    Symbol.Types t;
    AtribExp aE;
}
{
    (
        <tCHARACTER> { t = Symbol.Types.CHAR; }
        | <tBOOLEAN> { t = Symbol.Types.BOOL; }
        | <tINTEGER> { t = Symbol.Types.INT; }
    )
    <tOPENING_SQUARE_BRACKET>
    aE = expresionSimple()
    <tCLOSING_SQUARE_BRACKET>
    {
        return new AtribTipo(t, Integer.parseInt(aE.image));
    }
}

// --- INICIO DE variables.jj ---
ArrayList<String> listaIDs() :
{
    Token             token_id;
    ArrayList<String> ids = new ArrayList<String>();
}
{
    token_id = <tIDENTIFICADOR>    { ids.add(token_id.image); }
    (
      <tCOMA>
      token_id = <tIDENTIFICADOR>  { ids.add(token_id.image); }
    )*
    { return ids; }
}

void declaracionVariables() :
{
    AtribTipo         tipo_variables;
    ArrayList<String> ids;
}
{
    tipo_variables = tipo()
    ids            = listaIDs() 
    <tSEMICOLON>
    {
        declararVariablesGenerarCodigo(tipo_variables, ids);
    }
}

CodeBlock asignacionVariable() :
{
    Token token_id;
    AtribExp index_expr = null; 
    AtribExp value_expr;
}
{
    token_id = <tIDENTIFICADOR>
    ( 
      <tOPENING_SQUARE_BRACKET>
      index_expr = expresionSimple()
      <tCLOSING_SQUARE_BRACKET>
    )?
    <tASSIGN>
    value_expr = expresion()
    <tSEMICOLON>
    {
        return asignacionVariableGenerarCodigo(token_id.image, index_expr, value_expr);
    }
}

// --- INICIO DE expresiones.jj ---
AtribExp primario() :
{
    AtribExp prim, ae;
    Symbol s;
    Token t;
    ArrayList<AtribExp> lPar = new ArrayList<AtribExp>();
}
{
    (
        prim = entAcar()    { return prim; }
    | 
        prim = carAent()    { return prim; }
    |
        LOOKAHEAD(2)
        t = <tIDENTIFICADOR>
        <tOPENING_PARENTHESIS>
        lPar = parametros_llamada_funcion()
        {
            checkParameters(t, lPar);
        }
        <tCLOSING_PARENTHESIS>
        {
            try {
                s = st.getSymbol(t.image);
                SymbolFunction f = (SymbolFunction) s;
                prim = new AtribExp(f.returnType, false);
                prim.code.addComment("call " + t.image);
                for(int i = 0; i < lPar.size(); i++) {
                    if(f.parList.get(i).parClass == Symbol.ParameterClass.REF)
                        lPar.get(i).code.pop();
                    prim.code.addBlock(lPar.get(i).code);
                }
                prim.code.addOSFInst(CGUtils.memorySpaces[st.level], st.level - s.nivel, s.label);
                prim.code.addInst(PCodeInstruction.OpCode.DRF);
            } catch(SymbolNotFoundException e) {
                printError(String.format("Función \"%s\" no encontrada en la tabla de símbolos.", t.image));
                return new AtribExp();
            }
        }
    |
        LOOKAHEAD(2)
        t = <tIDENTIFICADOR>
        <tOPENING_SQUARE_BRACKET>
        ae = expresion()
        <tCLOSING_SQUARE_BRACKET>
        {
            try {
                s = st.getSymbol(t.image);
            } catch (SymbolNotFoundException e) {
                printError(String.format("Array \"%s\" no encontrada en tabla de símbolos.", t.image));
                return new AtribExp();
            }
            SymbolArray s_array = (SymbolArray) s;

            prim = new AtribExp(s_array.baseType, false);
            prim.code.addInst(PCodeInstruction.OpCode.SRF, st.level - s.nivel, s.offset);
            if(s.parClass == Symbol.ParameterClass.REF) prim.code.addInst(PCodeInstruction.OpCode.DRF);
            prim.code.addBlock(ae.code);
            prim.code.addInst(PCodeInstruction.OpCode.STC, s_array.minInd);
            prim.code.addInst(PCodeInstruction.OpCode.SBT);
            prim.code.addInst(PCodeInstruction.OpCode.STC, 1);
            prim.code.addInst(PCodeInstruction.OpCode.TMS);
            prim.code.addInst(PCodeInstruction.OpCode.PLUS);
            prim.code.addInst(PCodeInstruction.OpCode.DRF);
            return prim;
        }
    |
        t = <tIDENTIFICADOR>
        {
            try {
                s = st.getSymbol(t.image);
                prim = new AtribExp(s.type, false);
                prim.code.addInst(PCodeInstruction.OpCode.SRF, st.level - s.nivel, s.offset);
                prim.code.addInst(PCodeInstruction.OpCode.DRF);
                if(s.parClass == Symbol.ParameterClass.REF) prim.code.addInst(PCodeInstruction.OpCode.DRF);
                return prim;
            } catch (SymbolNotFoundException e) {
                printError(String.format("Identificador \"%s\" no encontrado en tabla de símbolos.", t.image));
                return new AtribExp();
            }
        }
    |
        t = <tCONSTANT>
        {
            prim = new AtribExp(Symbol.Types.INT, true, t.image);
            prim.code.addInst(PCodeInstruction.OpCode.STC, Integer.parseInt(t.image));
            return prim;
        }
    |
        t = <tCHAR>
        {
            prim = new AtribExp(Symbol.Types.CHAR, true, Character.toString(t.image.charAt(1)));
            prim.code.addInst(PCodeInstruction.OpCode.STC, (int) t.image.charAt(1));
            return prim;
        }
    |
        t = <tSTRING>
        {
            String cadena = t.image.substring(1, t.image.length() - 1);
            try {
                byte[] bytes = cadena.getBytes("UTF-8");
                prim = new AtribExp(Symbol.Types.STRING, true, cadena);
                for(int i = bytes.length - 1; i >= 0; --i)
                    prim.code.addInst(PCodeInstruction.OpCode.STC, (int) bytes[i]);
                return prim;
            } catch(UnsupportedEncodingException e) {
                printError("Carácter irreconocible");
                return new AtribExp();
            }
        }
    |
        <tTRUE>
        {
            prim = new AtribExp(Symbol.Types.BOOL, true, "true");
            prim.code.addInst(PCodeInstruction.OpCode.STC, 1);
            return prim;

        }
    |
        <tFALSE>
        {
            prim = new AtribExp(Symbol.Types.BOOL, true, "false");
            prim.code.addInst(PCodeInstruction.OpCode.STC, 0);
            return prim;
        }
    )
}

AtribExp factor() :
{
    Token op = null;
    AtribExp res;
    Boolean ok = true;
}
{
    ( op = <tNOT> | op = <tPLUS> | op = <tMINUS> )?
    (
        <tOPENING_PARENTHESIS> res = expresion() <tCLOSING_PARENTHESIS>
    |
        res = primario()
    )

    {
        if(op == null) return res;

        // SEMÁNTICO
        switch(op.image) {
            case "!": ok = typeEqual(Symbol.Types.BOOL, res.type,
                String.format("El operador \"%s\" requiere un valor de tipo BOOL, pero se ha proporcionado %s.", op.image, res.type));
                break;
            default: ok &=  typeEqual(Symbol.Types.INT, res.type,
                String.format("El operador \"%s\" requiere un valor de tipo INT, pero se ha proporcionado %s.", op.image, res.type));   
                break;
        }
        if(!ok) return new AtribExp();

        // GENERACIÓN DE CÓDIGO
        switch(op.image) {
            case "!":
                res.code.addInst(PCodeInstruction.OpCode.NGB); break;
            case "-":
                res.code.addInst(PCodeInstruction.OpCode.NGI); break;
            default:
                break; // "+" no afecta al entero
        }

        res.isConst = false;
        return res;
    }
}

AtribExp termino() :
{
    Token op = null;
    AtribExp left, right, aux;
    Boolean ok = true;
}
{
    left = factor() { aux = left; }
    ( 
        op = operador_multiplicativo()
        right = factor()
        
        {
            // SEMÁNTICO
            ok &= typeEqual(Symbol.Types.INT, Arrays.asList(aux.type, right.type),
                String.format("Los operandos del operador \"%s\" deben ser de tipo INT. Recibido %s %s %s.", op.image, aux.type, op.image, right.type));
            aux = AtribExp.copy(right);

            // GENERACIÓN DE CÓDIGO
            left.code.addBlock(right.code);
            switch(op.image.toLowerCase()) {
                case "*":
                    left.code.addInst(PCodeInstruction.OpCode.TMS); break;
                case "/":
                    left.code.addInst(PCodeInstruction.OpCode.DIV); break;
                case "mod":
                    left.code.addInst(PCodeInstruction.OpCode.MOD); break;
            }
        }
    )*
    {
        if(!ok) return new AtribExp();
        left.isConst = false;
        return left;
    }
}

AtribExp expresionSimple() :
{
    Token op = null;
    AtribExp left, right, aux;
    Boolean ok = true;
}
{
    left = termino() { aux = left; }
    ( 
        LOOKAHEAD(2) ( op = <tPLUS> | op = <tMINUS> )
        right = termino()

        {
            // SEMÁNTICO
            ok &= typeEqual(Symbol.Types.INT, Arrays.asList(aux.type, right.type),
                String.format("Los operandos del operador \"%s\" deben ser de tipo INT. Recibido %s %s %s.", op.image, aux.type, op.image, right.type));
            aux = AtribExp.copy(right);

            // GENERACIÓN DE CÓDIGO
            left.code.addBlock(right.code);
            switch(op.image.toLowerCase()) {
                case "+":
                    left.code.addInst(PCodeInstruction.OpCode.PLUS); break;
                case "-":
                    left.code.addInst(PCodeInstruction.OpCode.SBT); break;
            }
        }
    )*
    {
        if(!ok) return new AtribExp();
        left.isConst = false;
        return left;
    }
}

AtribExp relacion() :
{
    Token op = null;
    AtribExp left, right;
    Boolean ok = true;
}
{
    left = expresionSimple()
    (
        op = operador_relacional()
        right = expresionSimple()

        {
            // SEMÁNTICO
            if(op.image.matches("=|<>"))
                ok = typeEqual(left.type, right.type,
                    String.format("Los operandos del operador \"%s\" deben ser del mismo tipo. %s != %s.", op.image, left.type, right.type));
            else // <, <=, >, >=
                ok = typeEqual(Symbol.Types.INT, Arrays.asList(left.type, right.type),
                    String.format("Los operandos del operador \"%s\" deben ser de tipo INT. Se proporciono %s y %s.", op.image, left.type, right.type));
            
            if(!ok) return new AtribExp();

            // GENERACIÓN DE CÓDIGO
            left.code.addBlock(right.code);
            switch(op.image) {
                case "=":   left.code.addInst(PCodeInstruction.OpCode.EQ);  break;
                case "<>":  left.code.addInst(PCodeInstruction.OpCode.NEQ); break;
                case "<":   left.code.addInst(PCodeInstruction.OpCode.LT);  break;
                case "<=":  left.code.addInst(PCodeInstruction.OpCode.LTE); break;
                case ">":   left.code.addInst(PCodeInstruction.OpCode.GT);  break;
                case ">=":  left.code.addInst(PCodeInstruction.OpCode.GTE); break;
            }
        }
    )?
    {
        if(op != null) left.type = Symbol.Types.BOOL;
        left.isConst = false;
        return left;
    }
}

AtribExp expresion() :
{
    Token op = null;
    AtribExp left, right, aux;
    Boolean ok = true;
}
{
    left = relacion() { aux = left; }
    (
        ( op = <tAND> | op = <tOR> )
        right = relacion()

        {
            // SEMÁNTICO
            ok &= typeEqual(Symbol.Types.BOOL, Arrays.asList(aux.type, right.type),
                String.format("Los operandos para el operador \"%s\" deben ser de tipo BOOL. Recibido %s %s.", op.image, aux.type, right.type));
            aux = AtribExp.copy(right);

            // GENERACIÓN DE CÓDIGO
            left.code.addBlock(right.code);
            switch(op.image) {
                case "&":   left.code.addInst(PCodeInstruction.OpCode.AND);  break;
                case "|":  left.code.addInst(PCodeInstruction.OpCode.OR); break;
            }
        }
    )*
    {
        if(!ok) return new AtribExp();
        left.isConst = false;
        return left;
    }
}

void lista_una_o_mas_exps() :
{}
{
    ( expresion() )+
}

Token operador_multiplicativo() :
{
    Token t;
}
{
    t = <tTIMES>    { return t; }
  | t = <tDIVIDE>   { return t; }
  | t = <tMOD>      { return t; }
}

Token operador_relacional() :
{
    Token t;
}
{
    t = <tEQUAL>    { return t; }
  | t = <tNOTEQUAL> { return t; }
  | t = <tLT>       { return t; }
  | t = <tLE>       { return t; }
  | t = <tGT>       { return t; }
  | t = <tGE>       { return t; }
}

// --- INICIO DE funciones.jj ---
CodeBlock declaracion_proc_func() :
{
    CodeBlock res = new CodeBlock();
    CodeBlock aux = new CodeBlock();
}
{
    (
          aux = declaracion_proc()  { res.addBlock(aux); } 
        | aux = declaracion_func()  { res.addBlock(aux); }
    )+
    { return res; }
}

CodeBlock declaracion_proc() :
{
    Token t;
    ArrayList<Symbol> parametros = new ArrayList<Symbol>();
    CodeBlock cres = new CodeBlock();
    CodeBlock cinst = new CodeBlock();
    CodeBlock aux = new CodeBlock();
}
{
    t = <tIDENTIFICADOR>
    <tOPENING_PARENTHESIS>
    ( parametros = parametros_declaraciones() )?
    <tCLOSING_PARENTHESIS>
    {
        insertProcedure(t, parametros);
    }
    ( LOOKAHEAD(3) declaracionVariables() )*
    ( declaracion_proc() | declaracion_func() )*
    <tBEGGINING>
    ( aux = instruccion() { cinst.addBlock(aux); } )*
    <tEND>
    {
        // DECLARACIÓN DE CÓDGIO
        String etiqInicioProc = CGUtils.newLabel();
        st.getSymbol(t.image).label = etiqInicioProc;
        
        cres.addLabel(etiqInicioProc);
        
        // Parámetros
        for (int i = parametros.size() - 1; i >= 0; --i) {
            Symbol param = parametros.get(i);

            // General case: assign parameter value
            cres.addInst(OpCode.SRF, st.level - param.nivel, param.offset);
            cres.addInst(OpCode.ASGI);

            // Handle arrays passed by value
            if (param instanceof SymbolArray) {
                SymbolArray arrayParam = (SymbolArray) param;

                // Only copy if passed by value
                if (arrayParam.parClass == Symbol.ParameterClass.VAL) {
                    // Generate code to copy array contents into the local arrayParam.offset
                    CodeBlock copia = generarCopiaArray(arrayParam);
                    cres.addBlock(copia);
                }
            }
        }

        // Cuerpo procedimiento
        cres.addComment("inicio procedimiento " + t.image);
        cres.addBlock(cinst);

        // Fin procedimiento
        cres.addInst(OpCode.CSF);
        cres.addComment("fin procedimiento " + t.image);

        st.removeBlock();
        return cres;
    }
}

CodeBlock declaracion_func() :
{ 

    Token t;
    AtribTipo aT;
    ArrayList<Symbol> parametros = new ArrayList<Symbol>();
}
{
    aT = tipoEscalar()
    t = <tIDENTIFICADOR>
    < tOPENING_PARENTHESIS >
    ( parametros = parametros_declaraciones() )?
    < tCLOSING_PARENTHESIS >
    {
        insertFunction(t, aT, parametros);
    }
    ( LOOKAHEAD(3) declaracionVariables() )*
    ( declaracion_proc() | declaracion_func() )*
    < tBEGGINING >
    ( instruccion() )*
    < tEND >
    {
        st.removeBlock();
        return null;
    }
}

CodeBlock llamar_funcion() :
{ 
    ArrayList<AtribExp> lPar = new ArrayList<AtribExp>();
    Symbol fun;
    Token t;
    CodeBlock c = new CodeBlock();
}
{
    t = < tIDENTIFICADOR >
    < tOPENING_PARENTHESIS >
    lPar = parametros_llamada_funcion()
    {
        checkParameters(t, lPar);
    }
    < tCLOSING_PARENTHESIS >
    < tSEMICOLON >

    {
        // GENERACIÓN DE CÓDIGO
        try {
            fun = st.getSymbol(t.image);
        } catch (SymbolNotFoundException e) {
            printError(String.format("Función \"%s\" no encontrada en la tabla de símbolos.", t.image));
            return new CodeBlock();
        }
        c.addComment("call " + t.image);
        // añadir código de los parámetros
        if(fun instanceof SymbolFunction) {
            SymbolFunction f = (SymbolFunction) fun;
            for(int i = 0; i < lPar.size(); i++) {
                if(f.parList.get(i).parClass == Symbol.ParameterClass.REF)
                    lPar.get(i).code.pop();
                c.addBlock(lPar.get(i).code);
            }
            c.addOSFInst(CGUtils.memorySpaces[st.level], st.level - fun.nivel, fun.label);
        }
        if(fun instanceof SymbolProcedure) {
            SymbolProcedure p = (SymbolProcedure) fun;
            for(int i = 0; i < lPar.size(); i++) {
                if(p.parList.get(i).parClass == Symbol.ParameterClass.REF)
                    lPar.get(i).code.pop();
                c.addBlock(lPar.get(i).code);
            }
            c.addOSFInst(CGUtils.memorySpaces[st.level], st.level - fun.nivel, fun.label);
        }
            
        // si es una función (no procedimiento)
        if(fun instanceof SymbolFunction) {
            c.addInst(PCodeInstruction.OpCode.DRF);
        }

        return c;
    }
}

ArrayList<AtribExp> parametros_llamada_funcion() :
{ 
    ArrayList<AtribExp> lpar = new ArrayList<AtribExp>();
    AtribExp ae = null;    
}
{
    (  ae = expresion() )?
    {
        if(ae != null)
            lpar.add(ae);
    }
    (
        <tCOMA> ae = expresion()
        {
            if(ae != null)
                lpar.add(ae);
        }
    )*
    { return lpar; }
}

ArrayList<Symbol> parametros_declaraciones() :
{   
    AtribTipo aT;
    ArrayList<String> lVars;
    boolean isRef = false;
    ArrayList<Symbol> allSymbols = new ArrayList<Symbol>();
}
{
    aT = tipo()
    ( <tREF> { isRef = true; } )?
    lVars = listaIDs()
    {
        for (String id : lVars) {
            Symbol sV = null;
            if(aT.isArray) {
                sV = new SymbolArray(
                    id, 0, aT.size-1, aT.type, isRef ? Symbol.ParameterClass.REF : Symbol.ParameterClass.VAL);
            } else {
                switch(aT.type) {
                    case INT:
                        sV = new SymbolInt(
                            id, isRef ? Symbol.ParameterClass.REF : Symbol.ParameterClass.VAL);
                        break;
                    case BOOL:
                        sV = new SymbolBool(
                            id, isRef ? Symbol.ParameterClass.REF : Symbol.ParameterClass.VAL);
                        break;
                    case CHAR:
                        sV = new SymbolChar(
                            id, isRef ? Symbol.ParameterClass.REF : Symbol.ParameterClass.VAL);
                        break;
                    default:
                        printError("Tipo no válido.");
                        break;
                }
            }
            allSymbols.add(sV);
        }
        isRef = false;
    }
    (
        <tSEMICOLON>
        aT = tipo()
        ( <tREF> { isRef = true; } )? 
        lVars = listaIDs()
        {
        for (String id : lVars) {
                Symbol sV = null;
                if(aT.isArray) {
                    sV = new SymbolArray(
                        id, 0, aT.size-1, aT.type, isRef ? Symbol.ParameterClass.REF : Symbol.ParameterClass.VAL);
                } else {
                    switch(aT.type) {
                        case INT:
                            sV = new SymbolInt(
                                id, isRef ? Symbol.ParameterClass.REF : Symbol.ParameterClass.VAL);
                            break;
                        case BOOL:
                            sV = new SymbolBool(
                                id, isRef ? Symbol.ParameterClass.REF : Symbol.ParameterClass.VAL);
                            break;
                        case CHAR:
                            sV = new SymbolChar(
                                id, isRef ? Symbol.ParameterClass.REF : Symbol.ParameterClass.VAL);
                            break;
                        default:
                            System.out.println("Tipo no válido.");
                            break;
                    }
                }
                allSymbols.add(sV);
            }
        }
    )*
    { return allSymbols; }
}

// --- INICIO DE instrucciones.jj ---
CodeBlock instruccion() :
{
    CodeBlock c = new CodeBlock();
}
{
    (
    c =  escribir_linea() <tSEMICOLON>
    | c = escribir() <tSEMICOLON>
    | c = leer_linea() <tSEMICOLON>
    | c = leer() <tSEMICOLON>
    | entAcar() <tSEMICOLON> // no sirven de nada, si se llaman solas
    | carAent() <tSEMICOLON> // no sirven de nada, si se llaman solas
    | LOOKAHEAD(2) c = llamar_funcion()
    | LOOKAHEAD(2) c = asignacionVariable()
    | c = seleccion()
    | c = bucle()
    | LOOKAHEAD(2) ( declaracion_proc() | declaracion_func() )
    | <tABANDONAR> <tSEMICOLON>
    {
        code.addInst(OpCode.LVP, 0);
    }
    | <tNADA> <tSEMICOLON>
    {
        code.addInst(OpCode.NOP, 0);
    }
    )
    
    { return c; }
}

CodeBlock bucle() :
{
    AtribExp condicion;
    CodeBlock cuerpo = new CodeBlock();
    CodeBlock b = new CodeBlock();  // Bloque final para el bucle generado
    CodeBlock c;                    // Bloque temporal para cada instrucción
}
{
    <tITERATION>
    condicion = expresion()

    ( c = instruccion() { cuerpo.addBlock(c); } )*
    <tEND_ITERATION>
    {
        b = bucleGenerarCodigo(condicion, cuerpo);
    }
    { return b; }
}

CodeBlock seleccion() :
{
    AtribExp auxCond;
    CodeBlock cres = new CodeBlock(), auxInst;
    ArrayList<AtribExp> condiciones = new ArrayList<AtribExp>();
    ArrayList<CodeBlock> cuerpos = new ArrayList<CodeBlock>();
}
{
    <tSELECTION>
    (
        <tCASE>
        auxCond = expresion()   { condiciones.add(auxCond); }
        <tCOLON>
        auxInst = instrSelect() { cuerpos.add(auxInst); }
    )+
    [
        <tOTHERWISE> <tCOLON>
        auxInst = instrSelect() { cuerpos.add(auxInst); }
    ]
    <tEND_SELECTION>

    {
        // GENERACIÓN DE CÓDIGO
        cres.addComment("inicio select");
        int i;
        for(i = 0; i < condiciones.size(); ++i) {
            String etiq = CGUtils.newLabel();
            cres.addBlock(condiciones.get(i).code);
            cres.addInst(OpCode.JMF, etiq);
            cres.addBlock(cuerpos.get(i));
            cres.addLabel(etiq);
        }
        if(i == cuerpos.size() - 1) { // Hay Otherwise
            cres.addBlock(cuerpos.get(i));
        }
        cres.addComment("fin select");
        return cres;
    }
}

CodeBlock instrSelect() :
{
    CodeBlock cres = new CodeBlock(), aux;
}
{
    (
        aux = instruccion()     { cres.addBlock(aux); }
    )*
    { return cres; }
}

// --- INICIO DE especiales.jj ---
CodeBlock escribir_linea() :
{
    ArrayList<AtribExp> args = new ArrayList<AtribExp>();
    CodeBlock c = new CodeBlock();
}
{
    <tESCRIBIR_LIN>
    <tOPENING_PARENTHESIS>
    (args = escribir_params())?
    <tCLOSING_PARENTHESIS>
    {
        c.addComment("Comienzo escribir línea");
        for (AtribExp a : args) {
            c.addBlock(a.code);
            if(a.type == Symbol.Types.STRING) {
                for(int i = 0; i < a.code.getNumInstructions(); ++i)
                    c.addInst(OpCode.WRT, 0);
            }
            else if(a.type == Symbol.Types.CHAR) {
                c.addInst(OpCode.WRT, 0);
            }
            else if(a.type == Symbol.Types.INT) {
                c.addInst(OpCode.WRT, 1);
            }
        }
        // Salto de línea
        c.addInst(OpCode.STC, (int)'\n');
        c.addInst(OpCode.WRT, 0);
        c.addComment("Fin escribir línea");
        return c;
    }
}

CodeBlock escribir() :
{
    ArrayList<AtribExp> args = new ArrayList<AtribExp>();
    CodeBlock c = new CodeBlock();
}
{
    <tESCRIBIR>
    <tOPENING_PARENTHESIS>
    args = escribir_params()
    <tCLOSING_PARENTHESIS>
    {
        c.addComment("Comienzo escribir");
        for (AtribExp a : args) {
            c.addBlock(a.code);
            if(a.type == Symbol.Types.STRING) {
                for(int i = 0; i < a.code.getNumInstructions(); ++i)
                    c.addInst(OpCode.WRT, 0);
            }
            else if(a.type == Symbol.Types.CHAR) {
                c.addInst(OpCode.WRT, 0);
            }
            else if(a.type == Symbol.Types.INT) {
                c.addInst(OpCode.WRT, 1);
            }
        }
        c.addComment("Fin escribir");
        return c;
    }
}

ArrayList<AtribExp> escribir_params() :
{
    ArrayList<AtribExp> args = new ArrayList<AtribExp>();
    AtribExp a;
}
{
    (a = expresion()
    {
        typeNotEqual(Arrays.asList(Symbol.Types.ARRAY, Symbol.Types.PROCEDURE, Symbol.Types.UNDEFINED),
            a.type, String.format("No se puede escribir tipo de dato \"%s\"", a.type));
        args.add(a);
    }
    (
        <tCOMA> (a = expresion())
        {
            typeNotEqual(Arrays.asList(Symbol.Types.ARRAY, Symbol.Types.PROCEDURE, Symbol.Types.UNDEFINED),
            a.type, String.format("No se puede escribir tipo de dato \"%s\"", a.type));
            args.add(a);
        }
    )*)
    { return args; }
}

CodeBlock leer_linea() :
{
    ArrayList<String> lVars = new ArrayList<String>();
    CodeBlock c = new CodeBlock();
}
{
    <tLEER_LIN>
    <tOPENING_PARENTHESIS>
    (
        (lVars = listaIDs())
        {
            typeNotEqual(Arrays.asList(Symbol.Types.ARRAY, Symbol.Types.PROCEDURE, Symbol.Types.UNDEFINED, Symbol.Types.PROCEDURE), lVars);
            for (String id : lVars) {
                try {
                    Symbol s = st.getSymbol(id);
                    c.addComment("Comienzo leer");
                    c.addInst(OpCode.SRF, st.level - s.nivel, s.offset);
                    int tipo = (s.type == Symbol.Types.CHAR) ? 0 : 1;
                    c.addInst(OpCode.RD, tipo);
                    c.addComment("Fin leer");
                } catch (SymbolNotFoundException e) {
                    printError("Variable \"" + id + "\" no encontrada.");
                }
            }
        }
    )?
    <tCLOSING_PARENTHESIS>

    { return c; }
}

CodeBlock leer() :
{
    ArrayList<String> lVars = new ArrayList<String>();
    CodeBlock c = new CodeBlock();
}
{
    <tLEER> 
    <tOPENING_PARENTHESIS>
    lVars = listaIDs()
    {
        typeNotEqual(Arrays.asList(Symbol.Types.ARRAY, Symbol.Types.PROCEDURE, Symbol.Types.UNDEFINED, Symbol.Types.PROCEDURE), lVars);
        for(String id : lVars) {
            try {
                Symbol s = st.getSymbol(id);
                c.addComment("Comienzo leer línea");
                c.addInst(OpCode.SRF, st.level - s.nivel, s.offset);
                int tipo = (s.type == Symbol.Types.CHAR) ? 0 : 1;
                c.addInst(OpCode.RD, tipo);
                c.addComment("Fin leer línea");
            } catch (SymbolNotFoundException e) {
                printError("Variable \"" + id + "\" no encontrada.");
            }
        }
    }
    <tCLOSING_PARENTHESIS> 
    { return c; }
}

AtribExp entAcar() :
{
    AtribExp res;
}
{
    < tENTACAR >
    <tOPENING_PARENTHESIS>
    res = expresionSimple()
    <tCLOSING_PARENTHESIS>

    {
        if(!typeEqual(Symbol.Types.INT, res.type, String.format("Tipo incorrecto. Se esperaba INT pero se encontró %s.", res.type))) {
            return new AtribExp(); 
        }
        // No hace falta transformarlo porque CHAR e INT son ambos 32 bits en máquina P
        res.type = Symbol.Types.CHAR;
        res.isConst = true;
        return res;
    }
}

AtribExp carAent() :
{
    AtribExp res;
}
{
    < tCARAENT >
    < tOPENING_PARENTHESIS>
    res = primario()
    <tCLOSING_PARENTHESIS>

    {
        if(!typeEqual(Symbol.Types.CHAR, res.type, String.format("Tipo incorrecto. Se esperaba CHAR pero se encontró %s.", res.type))) {
            return new AtribExp();
        }
        // No hace falta transformarlo porque CHAR e INT son ambos 32 bits en máquina P
        res.type = Symbol.Types.INT;
        res.isConst = true;
        return res;
    }
}

